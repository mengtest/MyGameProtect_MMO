//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.1022
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
using BattleFramework.Data;
using UnityEngine.UI;
public class GameCommonUtils
{
	public GameCommonUtils ()
	{
	}
	private static GameCommonUtils instance;

	public static GameCommonUtils Instance{
		get{
			if(instance == null){
				instance = new GameCommonUtils();
			}
			return instance;
		}
	}
	public string FormatNumber(int source)
	{
		string target = source > 999999 ? ((int)(source / 10000)) + "万" : source.ToString();
		return target;
	}

	
    public String LastTimeFormat(int second)
    {
        int day = second / (24 * 3600);
        int hour = (second % (24 * 3600)) / 3600;
        int minute = (second % 3600) / 60;
        int leftSecond = second % 60;
        string temp = "";
        if(day > 0 ){
            temp = day + "天" + hour + "时";
        }else if(hour > 0){
            temp = hour + "时" + minute + "分";
        }else if (minute > 0)
        {
            temp = minute + "分" + leftSecond + "秒";
        }
        else if (leftSecond > 0)
        {
            temp  = leftSecond + "秒";
        }
        return temp;
    }
    public String TimeFormat_HH_MM_SS(int second,string format = "hh:mm:ss")
    {
        int day = second / (24 * 3600);
        int hour = (second % (24 * 3600)) / 3600;
        int minute = (second % 3600) / 60;
        int leftSecond = second % 60;

         if(hour > 9)
         {
             format = format.Replace("hh", hour.ToString());
         }
         else if(hour > 0)
         {
             format = format.Replace("hh", "0" + hour.ToString());
         }
         else
         {
             format = format.Replace("hh", "00");
         }

         if (minute > 9)
         {
             format = format.Replace("mm", minute.ToString());
         }
         else if (minute > 0)
         {
             format = format.Replace("mm", "0" + minute.ToString());
         }
         else
         {
             format = format.Replace("mm", "00");
         }

         if (leftSecond > 9)
         {
             format = format.Replace("ss", leftSecond.ToString());
         }
         else if (leftSecond > 0)
         {
             format = format.Replace("ss", "0" + leftSecond.ToString());
         }
         else
         {
             format = format.Replace("ss", "00");
         }
         return format;
    }
   

    static public void Destroy(UnityEngine.Object obj)
    {
        if (obj)
        {
            if (obj is Transform)
            {
                Transform t = (obj as Transform);
                GameObject go = t.gameObject;

                if (Application.isPlaying)
                {
                    t.SetParent(null);
                    UnityEngine.Object.Destroy(go);
                }
                else UnityEngine.Object.DestroyImmediate(go);
            }
            else if (obj is GameObject)
            {
                GameObject go = obj as GameObject;
                Transform t = go.transform;

                if (Application.isPlaying)
                {
                    t.parent = null;
                    UnityEngine.Object.Destroy(go);
                }
                else UnityEngine.Object.DestroyImmediate(go);
            }
            else if (Application.isPlaying) UnityEngine.Object.Destroy(obj);
            else UnityEngine.Object.DestroyImmediate(obj);
        }
    }

    public Color Convet16StringToColor(string str)
    {
        int intValue = Convert.ToInt32(str, 16);
        byte b = (byte)(intValue % 256);
        byte g = (byte)((intValue / 256) % 256);
        byte r = (byte)(intValue / (256 * 256));
        return new Color32(r,g,b,255);
    }
    
    /// <summary>
    /// 获取粒子特效播放时间
    /// </summary>
    /// <param name="t"></param>
    /// <returns></returns>
    public float GetParticleSystemPlayTime(Transform t)
    {
        ParticleSystem[] particleSystems = t.GetComponentsInChildren<ParticleSystem>();
        float maxDuration = 0;
        foreach (ParticleSystem ps in particleSystems)
        {
            if (ps.enableEmission)
            {
                if (ps.loop)
                {
                    return -1f;
                }
                float dunration = 0f;
                if (ps.emissionRate <= 0)
                {
                    dunration = ps.startDelay + ps.startLifetime;
                }
                else
                {
                    dunration = ps.startDelay + Mathf.Max(ps.duration, ps.startLifetime);
                }
                if (dunration > maxDuration)
                {
                    maxDuration = dunration;
                }
            }
        }
        return maxDuration;
    }


    /// <summary>
    /// 将阿拉伯数字转换成汉字
    /// </summary>
    /// <param name="num"></param>
    /// <returns></returns>
    public string SwitchNumToHanZi(int num)
    {
        if (num > 9)
        {
            return "";
        }
        string result = "";
        switch (num)
        {
            case 1:
                result = "一";
                break;
            case 2:
                result = "二";
                break;
            case 3:
                result = "三";
                break;
            case 4:
                result = "四";
                break;
            case 5:
                result = "五";
                break;
            case 6:
                result = "六";
                break;
            case 7:
                result = "七";
                break;
            case 8:
                result = "八";
                break;
            case 9:
                result = "九";
                break;
        }
        return result;
    }

    /// <summary>
    /// 将时间戳转化为TimeData;
    /// </summary>
    /// <param name="timeStamp"></param>
    /// <returns></returns>
    public DateTime StampToDataTime(long timeStamp)
    {
        DateTime startDataTime = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1));
        long time = timeStamp * 10000000;
        TimeSpan toStamp = new TimeSpan(time);
        return startDataTime.Add(toStamp);
    }


    /// <summary>
    ///  将TimeData转换为时间戳
    /// </summary>
    /// <param name="time"></param>
    /// <returns></returns>
    public long DataTimeToStamp(DateTime time)
    {
        DateTime startDataTime = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1));
        return (long)((time - startDataTime).TotalSeconds);
    }
    /// <summary>
    /// 转向目标
    /// </summary>
    /// <param name="source"></param>
    /// <param name="target"></param>
    public void RotateToTarget(Transform source , Vector3 target)
    {
        Vector3 relative = source.InverseTransformPoint(target);
        float angle = Mathf.Atan2(relative.x, relative.z) * Mathf.Rad2Deg;
        source.Rotate(Vector3.up, angle);
    }

    public int GetLayer(string layerName)
    {
        return (1 << LayerMask.NameToLayer(layerName));
    }
    /// <summary>
    /// var cube = new GameObject();
    //  var filter = cube.AddComponent<MeshFilter>();
    //  cube.AddComponent<MeshRenderer>();
    /// </summary>
    /// <param name="center"></param>
    /// <param name="canvas"></param>
    /// <param name="filter"></param>
    /// <param name="raidus"></param>
    /// <param name="angle"></param>
    /// <param name="offsetX"></param>
    /// <param name="offsetY"></param>
    /// <param name="angleOffset"></param>
    /// <param name="posType"></param>
    public void DrawCircle(GameObject center,GameObject canvas, MeshFilter filter, float raidus, float angle, float offsetX = 0, float offsetY = 0, float angleOffset = 0, int posType = 0)
    {
        int ANGLE_STEP = 15;
        var mesh = new Mesh();
        int len = (int)Math.Floor(angle / ANGLE_STEP);
        len = len + 2;
        Vector3[] vs = new Vector3[len];
        float sin = (float)Math.Sin(angleOffset * Math.PI / 180);
        float cos = (float)Math.Cos(angleOffset * Math.PI / 180);
     
        Matrix4x4 m = center.transform.localToWorldMatrix;
        Matrix4x4 m1 = new Matrix4x4();
        m1.SetRow(0, new Vector4(0, 0, 0, offsetY)); //1
        m1.SetRow(1, new Vector4(0, 1, 0, 0));
        m1.SetRow(2, new Vector4(0, 0, 0, offsetX)); //-1
        m1.SetRow(3, new Vector4(0, 0, 0, 1));
        m = m * m1;
        Vector3 v0 = new Vector3(m.m03, m.m13, m.m23);
        //vs[0] = theOwner.Transform.position;
        vs[0] = v0;
        for (int i = 1; i < len; i++)
        {
            //canvas.transform.position = theOwner.Transform.position;
            canvas.transform.position = v0;
            canvas.transform.rotation = center.transform.rotation;
            canvas.transform.Rotate(new Vector3(0, -angle * 0.5f, 0));
            if (i != len - 1)
            {//非最后一个点
                canvas.transform.Rotate(new Vector3(0, ANGLE_STEP * i, 0));
                var v = canvas.transform.position + canvas.transform.forward * raidus;
                vs[i] = v;
            }
            else
            {//最后一个顶点
                //float r = angle - ANGLE_STEP * (i - 1);
                canvas.transform.Rotate(new Vector3(0, angle, 0));
                var v = canvas.transform.position + canvas.transform.forward * raidus;
                vs[i] = v;
            }
        }
        //三角形数
        int tc = len - 2;
        int[] triangles = new int[tc * 3];
        for (int j = 0; j < tc; j++)
        {
            triangles[j * 3] = 0;
            triangles[j * 3 + 1] = j + 1;
            if (j != 23)
            {
                triangles[j * 3 + 2] = j + 2;
            }
            else
            {
                triangles[j * 3 + 2] = 1;
            }
        }
        canvas.transform.position = Vector3.zero;
        canvas.transform.rotation = new Quaternion();
        mesh.vertices = vs;
        mesh.triangles = triangles;
        filter.mesh = mesh;
    }

    /// <summary>
    /// 绘制矩形
    /// </summary>
    /// <param name="center"></param>
    public void DrawRect(GameObject center)
    {
        float offsetY = 0;
        float offsetX = 0;
        float h = 10f;
        float w = 10f;
        var cube = new GameObject();
        var filter = cube.AddComponent<MeshFilter>();
        cube.AddComponent<MeshRenderer>();
        //float sin = (float)Math.Sin(angleOffset * Math.PI / 180);
        //float cos = (float)Math.Cos(angleOffset * Math.PI / 180);
        Matrix4x4 m = center.transform.localToWorldMatrix;
        Matrix4x4 m1 = new Matrix4x4();
        m1.SetRow(0, new Vector4(0, 0, 0, offsetY)); //1
        m1.SetRow(1, new Vector4(0, 1, 0, 0));
        m1.SetRow(2, new Vector4(0, 0, 0, offsetX)); //-1
        m1.SetRow(3, new Vector4(0, 0, 0, 1));
        m = m * m1;
        Vector3 posi = new Vector3(m.m03, m.m13, m.m23);
        var mesh = new Mesh();
        //cube.transform.position = theOwner.Transform.position;
        cube.transform.position = posi;
        cube.transform.rotation = center.transform.rotation;
        cube.transform.Rotate(new Vector3(0, 90, 0));
        var v0 = cube.transform.position + cube.transform.forward * w * 0.5f;

        cube.transform.position = v0;
        cube.transform.rotation = center.transform.rotation;
        var v1 = cube.transform.position + cube.transform.forward * h;

        //cube.transform.position = theOwner.Transform.position;
        cube.transform.position = posi;
        cube.transform.rotation = center.transform.rotation;
        cube.transform.Rotate(new Vector3(0, -90, 0));
        var v2 = cube.transform.position + cube.transform.forward * w * 0.5f;

        cube.transform.position = v2;
        cube.transform.rotation = center.transform.rotation;
        var v3 = cube.transform.position + cube.transform.forward * h;

        cube.transform.position = Vector3.zero;
        cube.transform.rotation = new Quaternion();
        mesh.vertices = new Vector3[] { v0, v1, v2, v3 };
        mesh.triangles = new int[] { 2, 1, 0, 2, 3, 1 };
        filter.mesh = mesh;
    }
    
}




